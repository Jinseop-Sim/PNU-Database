# Data Modeling
---
## History of Data Modeling
### Edgar F. Codd
> "A Relational model of data for large shared data banks" - CACM(1970)  
- He proposed a mathematical model to handle data in an algebric way with a set of operators
- It is called __RDM(Relational Data Model)__

### Peter Chen
> "The Entity-Relationship Moddel - Toward a unified view of data"(1976)  
- He used __Table__
- Table can describe everything in real world
- More expressive power than RDM
- Everything by means of __Entity Set__ and __Relationship__

### James Rambaugh
> "Object-Oriented Modeling and Design"(1990)  
- Object-Oriented Language(객체 지향 언어)의 대표적 특징은, Encapsulation(캡슐화)
  - 무슨 내용물인지 알 필요가 없이, 그냥 우리가 사용만 하면 된다.
- Relational Model이 진화를 한 방식이 바로 Object-Oriented Model이다.
- 결국 1999년에 UML로 통합된다.

## What is Class Diagram?
- It is Part of UML Diagram(richest notation of UML)
- Describes
  - Types of objects in system(e.g. 직업, 나이, 이름..)
  - 위의 Objects들 간에 존재하는 다양한 통계적 관계에 대해 묘사한다.
  - Graphical representation of a static view on declarative static elements
- Essential elements of a UML Class Diagram
  - Class
  - Attributes
  - Operations
  - Relationships
    - Associations
    - Generalizations
    - Dependancy
    - Realization
  - Constraint rules and Notes  
![Example of UML](https://user-images.githubusercontent.com/71700079/132525374-8c80c5d6-869b-4f5d-8ec5-6d5f59f7f7f1.png)  

- Classes?
  - Class : Description of a set of objects having similar, 이름은 명사로 지어질 수 있다.
    - Attributes
    - Operations
    - Relationships and Behavior
  (e.g. Class | Window  
        Attributes | size : Size, visibility : boolean  
        Operations | display(), hide())
- Associations : Name and Role
  - A semantic relationship between classes : To specify connections among their instances
  - A structual relationship : To specify that objects of one class are connected to objects of second class(e.g. An Employee "work for" a Company)
  - Association has a name
    - To clarify it's meaning
    - The name is represented as a label placed midway along the association line
    - Usually a verb or a verb phrase
  - A role is an end of an association where it connects to a class  
  ![Class Relationship](https://user-images.githubusercontent.com/71700079/133072772-c2e09aa0-a4af-4b0a-bc30-e4da24d29412.png)  
  - Association은 위 그림과 같이 방향성을 가지는데, 위와 같은 관계를 단방향 연결이라고 한다.
  - 쌍방향으로 만드려면 하나의 관계를 더 implement해야 한다.
  - 자기 자신에게 돌아오는 화살표가 그려지는 경우가 있는데, 이는 재귀적 연관(Reflexive)라고 하며, 수업을 예로 들자면 선행 수업의 수 같은 것이다.
  - Notation of Cardinality(Multiplicity)
    - 하나 밖에 없다 : 1
    - 0이거나 더 많이 있다.(Unlimited) : * (0..*)
    - 1 혹은 더 많이 있다. : 1..*
    - 0 혹은 1이다. : 0..1
    - 구체적인 범위 : 2..4
    - 범위의 분리 : 2, 4..6, 8
    - Cardinality가 적혀있지 않으면 1..1이라고 볼 수 있다. 하지만? 애매모호하다.
  
  - Association Class : 그냥 Class Relationship을 보면 Association에 대한 자세한 설명이 적혀있지 않아 알 수 없다. 따라서 아래와 같이 Association Class를 정의한다.  
  ![Association Class](https://user-images.githubusercontent.com/71700079/133073426-7b627d25-589b-4f25-9028-f0c2b45a1cc1.png)  
  
  - Aggregation : Association  
    ![Aggregation](https://user-images.githubusercontent.com/71700079/133081767-5b502080-a8e5-41ca-b57b-0b340f5ac162.png)  
    - Whole Class의 Cardinality를 적지 않아도 된다.
    - 대개 1 to many로 구성된다.
    - Whole Class의 Life Cycle은 Part Class의 Life cycle와 서로 영향 받지 않는다.
    - 즉 Whole Class가 사라지더라도, Part Class는 소멸되지 않는다.
  
  - Composition(Strong Aggregation)  
    ![Composition](https://user-images.githubusercontent.com/71700079/133081780-856d89f5-900d-42f9-96a7-43a3f6a01cf5.png)  
    - 특수한 경우의 Aggregation 이다.
    - 대개 1 to 1로 구성된다.
    - 상위 클래스의 Cardinality를 굳이 적을 필요가 없다. why?) 1대1대응이니까.
    - 상위 클래스가 죽으면, 하위 클래스 또한 소멸된다.
  
  - Generalization  
    ![Generalization](https://user-images.githubusercontent.com/71700079/133081791-a8c77b1c-336f-43f4-b2f0-74f278bb38be.png)  
    - "is kind of"의 관계를 갖는 Relation이다.
    - 일반적인 상위 클래스에 대해서 모두 공통점을 갖는 하위 클래스들이 존재한다.
    - 하위 클래스는 상위 클래스의 모든 속성(Attributes)를 물려받는다. 따라서 하위로 내려갈 수록 많은 속성을 갖는다.(Inheritance)
    - 반대의 경우는 Specialization이라고 한다.
  
  - Constraint
  > UML Diagram으로 모든 의미론적(Semantic) 내용을 표현하는 것은 불가능하다.  
  > 따라서 우리는 Constraint를 이용해서 더욱 더 풍성한 표현이 가능해진다.  
    - Key Constraint(키 제약)
      - Key?
        - Key는 각 Object를 구분할 수 있는 한 개 또는 그 이상의 집합이 된다.
        - 서로 다른 Object들은 같은 Key를 가질 수 없다.
        - 객체를 구별하고 가장 명확하게 특징을 보여주는 Key를 우리는 PK(Primary Key, 기본키)라고 칭한다.
        - 예를 들어, Employee 클래스가 있다고 가정하면 그 클래스의 PK 집합은 (name, address)라고 할 수 있을 것이다.
    - Referential Integrity(참조 무결성)
      - 참조 무결성이란, 다른 객체에 의해 참조되는 값은 무조건 DB 내에 존재해야만 한다는 규칙이다.
      - 우리는 외래키(Foreign Key)를 이용해서 다른 객체의 PK(기본키)를 참조를 할 수 있도록 되어있는데, 외래키 참조 시에 객체가 존재하지 않는다면 오작동을 하게 된다.
      - 따라서 우리는 참조 무결성 Constraint를 걸어서 이런 오류가 없게 해야한다.
  
  ## Sample Modeling : RFID
