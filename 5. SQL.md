# SQL
---
## SQL(Structured Query Language)
> 왜 SQL을 쓸까?  
> 방대한 양의 데이터를 구체적으로 특정하지 않고도 제어할 수 있는 고 레벨의 언어이기 때문이다.  

## Data Definition
### CREATE TABLE : Make table
  ```SQL
  CREATE TABLE Moive(
    title VARCHAR(10),
    year INT
  );
  
  DROP TABLE Movie; // 테이블 삭제.
  ```
### Element Declaration
  - INT(INTEGER)
  - REAL(FLOAT)
  - CHAR(n) : fixed length 'n'
  - VARCHAR(n) : string up to 'n'
### Dates and Times
  - DATE '2002-09-30' : Type of DATE
  - TIME '15:30:02.5' : Type of TIME
### Define Keys
  ```SQL
  CREATE TABLE Beers(
    name CHAR(20) UNIQUE, // Same as PRIMARY KEY
    manf CHAR(20)
  );

  CREATE TABLE Sells( // Multiattribute KEY
    bar CHAR(20),
    beer VARCHAR(20),
    price REAL,
    PRIMARY KEY(bar, beer)
  );
  ```
  - 여기서, PRIMARY KEY와 UNIQUE의 차이는
  - PRIMARY KEY는 NULL Attribute가 어떤 Tuple 내에도 존재해서는 안된다.
  - UNIQUE는 NULL Attribute 또한 존재할 수 있다.

### Other Declaration for Attributes
  ```SQL
  CREATE TABLE Drinkers(
    name CHAR(30) PRIMARY KEY,
    addr CHAR(50) DEFAULT '123 Sesame St.',
    phone CHAR(16) NOT NULL
  );
  ```
### Inserting a Tuple
  ```SQL
  INSERT INTO Drinkers(name, addr, phone)
  VALUES ('Jin-Seop Sim', 'Pusan 234', '010-1234-5678');
  ```
  - 만약 필요한 Attribute를 다 입력하지 않으면 어떻게 될까? 그럼 NULL 값으로 채워지게 되므로, Anomaly가 발생할 수가 있다!
  - 따라서 반드시 NOT NULL 선언을 해주어야 NULL 값이 들어가지 않는다.

### Adding Attributes
  ```SQL
  ALTER TABLE Bars ADD
    phone char(16) DEFAULT 'unlisted';
  ```
### Deleting Attributes
  ```SQL
  DROP TABLE Bars
    DROP license;
  ```
- Views in SQL
  ```SQL
  CREATE VIEW CanDrink AS
    SELETC drinker, beer
    FROM Frequents, Sells
    WHERE Frequents.bar = Sells.bar;
  ```
  - SQL에는 View라는 __Virtual Table__ 이 존재한다.
  - 이는 DB에 물리적으로 구현되어 있지 않은 가상의 테이블이며, 전체 데이터에 대해 일부만 열람 가능하도록 할 수 있게 만든 테이블이다.
  - 뷰의 수정 결과는 뷰를 정의한 기본 테이블에도 똑같이 적용된다.
  - 장점
    - 사용자에 따라 특정 정보만 접근이 가능하도록 하므로, DB 보안에 용이하다.
    - 복잡한 명령문이 간단해진다.
  - 단점
    - 뷰의 정의를 바꿀 수 없다.
    - 삽입, 갱신, 삭제 연산에 대해 제한이 있다.

## Data Manipulation
### Select-From-Where
- Select : Projection과 동일한 기능을 한다
- From : Select와 동일한 기능을 한다.
- Where : 어떤 Relation에서 가져올 것인가?

``` SQL
SELECT name // Beers Table의 OB에서 Manf한 Beer의 Name을 Projection 해라.
FROM Beers
WHERE manf = 'OB'; // Condition을 걸어서 Relation을 지정할 수 있다.
```
- ```SELECT``` 명령문에서 ```*``` 를 붙이게 되면 __모든 Attribute__ 라는 의미가 된다.
- Renaming Attributes
```SQL
SELECT name AS Beer, manf AS Company // name을 Beer이란 이름으로 Projection하고 manf를 Company란 이름으로 Projection한다.
FROM Beers
WHERE manf = 'OB';

SELECT name, 'EXPENSIVE' AS PriceRate // PriceRate라는 Column을 새로 만들어 EXPENSIVE라는 문구로 채운다.
FROM Beers
WHERE price > 40;
```
- Expressions in SELECT
```SQL
SELECT price * 2 AS new_price // 가격에 X2를 한 결과로 Projection을 한다.
FROM Sells;
```
### Patterns in DB
- % : 모든 문자열을 탐색하는 패턴 (ex) bl% ==> bl, black, blue, blur..)
- _ : 모든 CHAR을 탐색하는 패턴 (ex) h_t ==> hat, hit, hot..)
- [] : [] 안에 있는 CHAR이 들어간 단어가 있는 지 찾을 수 있다. (ex) h[oa]t ==> hat, hot)
- ^ : ^뒤에 오는 CHAR이 들어간 단어가 아닌 단어들을 찾는다. (ex) h[^oa]t ==> hit, hut...)
- - : [] 안에 찾을 CHAR의 범위를 지정한다. (ex) h[a-c]t ==> hat, hbt, hct)
- Example
```SQL
SELECT name
FROM Drinkers
WHERE phone LIKE '%555-_ _ _ _'; // 핸드폰 번호가 ???555-???? 인 사람들을 찾는 것.
```

### NULL Values
> SQL Relation 내의 Tuple들은 하나 이상의 NULL 값을 가질 수 있다.
- Comparing NULL with values : __With Three Valued Logic(TRUE, FALSE, UNKNOWN)__
  - 어떤 값이든지 NULL과 비교를 하면 __진리 값(Truth value)__ 은 __UNKNOWN__ 이 된다.
  - 어떤 값이든지 NULL과 연산을 하면 __값(Value)__ 은 __UNKNWON__ 이 되어 버린다.
  - 하지만 Query는 WHERE 구문에 대한 값이 TRUE일 때만 Tuple을 생성한다.

### Three Valued Logic
- TRUE = 1, FALSE = 0, UNKNWON = 1/2.
- AND = MIN, OR = MAX, NOT(x) = 1-x.
- Example
  - TRUE AND (FALSE OR NOT(UNKNOWN)) = MIN(1, MAX(0, (1-1/2))) = 1/2 = __UNKNOWN__
  - 어떤 값이든지 NULL과 연산하면 __UNKNOWN__ 이 된다고 했다.
- 왜 2 Valued Logic의 법칙과 3 Valued Logic의 법칙은 다른가?
  - p OR NOT p = TRUE(2 Valued)
  - p가 UNKNOWN 이라고 가정하면, 위의 식의 결과는 당연히 1/2(UNKNOWN)이 된다.
  - 따라서 둘은 아예 다른 법칙을 가진다!

## Multi-Relation Queries
> 제목 그대로 하나 이상의 Relation을 참조하는 Query이다.  
> FROM 구문 내에 1개 이상의 Relation을 집어 넣는다.  
```SQL
SELECT beer
FROM Likes, Frequents // 두 개의 Relation을 참조.
WHERE bar = 'Joe''s Bar' AND Frequents.drinker = Likes.drinker; // 서로 다른 Relation 이지만 같은 이름의 Attribute가 존재, Dot으로 구분.
```
- 이를 표로 가시화 시키면 아래와 같다.
![image](https://user-images.githubusercontent.com/71700079/142446009-4434de06-fefc-4261-b8a8-0a8a107b1b28.png)  


```
## Subqueries
### IN operator
### Exists operator
### Any operator
### All operator
